<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Cross Stitch Pattern Maker</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        text-align: center;
        padding: 18px;
      }
      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        margin: 8px 0;
      }
      canvas {
        border: 1px solid #ddd;
        margin-top: 12px;
        max-width: 100%;
        height: auto;
        background: white;
      }
      label {
        font-size: 14px;
      }
      button {
        padding: 6px 10px;
      }
      .small {
        font-size: 13px;
        color: #444;
      }
    </style>
  </head>
  <body>
    <h2>Cross Stitch Pattern Maker</h2>

    <input type="file" id="upload" accept="image/*" /><br />

    <div class="controls">
      <label
        >Block size (px)
        <input id="gridSize" type="range" min="5" max="60" value="20" />
      </label>
      <span id="gridValue">20</span>

      <label
        >Color levels
        <input id="colorDepth" type="range" min="2" max="64" value="16" />
      </label>
      <span id="depthValue">16</span>

      <button id="toggleGrid">Toggle Grid</button>
      <button id="download">Download PNG</button>
    </div>

    <canvas id="canvas"></canvas>
    <p class="small">
      Block size = how many screen pixels each stitch/block will take. Increase
      to make fewer larger blocks.
    </p>

    <script>
      const MAX_DIM = 800; // max width or height for the visible canvas

      const upload = document.getElementById("upload");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const gridSizeInput = document.getElementById("gridSize");
      const gridValue = document.getElementById("gridValue");
      const depthInput = document.getElementById("colorDepth");
      const depthValue = document.getElementById("depthValue");
      const toggleGridBtn = document.getElementById("toggleGrid");
      const downloadBtn = document.getElementById("download");

      let img = new Image();
      let scaledCanvas = null;
      let scaledWidth = 0,
        scaledHeight = 0;
      let showGrid = true;

      upload.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          img = new Image();
          img.onload = onImageLoad;
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });

      function onImageLoad() {
        const scale = Math.min(MAX_DIM / img.width, MAX_DIM / img.height, 1);
        scaledWidth = Math.round(img.width * scale);
        scaledHeight = Math.round(img.height * scale);

        scaledCanvas = document.createElement("canvas");
        scaledCanvas.width = scaledWidth;
        scaledCanvas.height = scaledHeight;
        const sctx = scaledCanvas.getContext("2d");
        sctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);

        canvas.width = scaledWidth;
        canvas.height = scaledHeight;

        render();
      }

      function render() {
        if (!scaledCanvas) return;

        const block = parseInt(gridSizeInput.value, 10);
        const levels = parseInt(depthInput.value, 10);

        gridValue.textContent = block;
        depthValue.textContent = levels;

        // compute how many blocks across and down
        const cols = Math.ceil(scaledWidth / block);
        const rows = Math.ceil(scaledHeight / block);

        // downsample source image to cols Ã— rows
        const temp = document.createElement("canvas");
        temp.width = cols;
        temp.height = rows;
        const tctx = temp.getContext("2d");
        tctx.drawImage(scaledCanvas, 0, 0, cols, rows);

        // quantize colors
        const imgData = tctx.getImageData(0, 0, cols, rows);
        const step = 256 / levels;
        for (let i = 0; i < imgData.data.length; i += 4) {
          for (let c = 0; c < 3; c++) {
            let v = imgData.data[i + c];
            let q = Math.floor(v / step) * step + step / 2;
            if (q > 255) q = 255;
            imgData.data[i + c] = q;
          }
        }
        tctx.putImageData(imgData, 0, 0);

        // clear and redraw as perfect blocks
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const data = imgData.data;
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const idx = (y * cols + x) * 4;
            ctx.fillStyle = `rgb(${data[idx]},${data[idx + 1]},${
              data[idx + 2]
            })`;
            ctx.fillRect(x * block, y * block, block, block);
          }
        }

        // draw grid if enabled
        if (showGrid) {
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.lineWidth = 1;
          for (let x = 0; x <= cols; x++) {
            ctx.beginPath();
            ctx.moveTo(x * block + 0.5, 0);
            ctx.lineTo(x * block + 0.5, rows * block);
            ctx.stroke();
          }
          for (let y = 0; y <= rows; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y * block + 0.5);
            ctx.lineTo(cols * block, y * block + 0.5);
            ctx.stroke();
          }
        }
      }

      gridSizeInput.addEventListener("input", render);
      depthInput.addEventListener("input", render);

      toggleGridBtn.addEventListener("click", () => {
        showGrid = !showGrid;
        render();
      });

      downloadBtn.addEventListener("click", () => {
        if (!scaledCanvas) return;
        const link = document.createElement("a");
        link.download = "cross-stitch-pattern.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    </script>
  </body>
</html>
